#!/bin/bash

# Custom access script for Kubernetes Goat with network binding
# This script exposes services to the network instead of just localhost

BIND_ADDRESS="{{ kubernetes_goat_bind_address }}"
LOG_FILE="/var/log/kubernetes-goat-portforward.log"
KUBECTL="/usr/local/bin/kubectl"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log "Starting Kubernetes Goat network access on ${BIND_ADDRESS}"
log "Using kubectl at: $KUBECTL"

# Function to check if pod is running
wait_for_pod() {
    local app_label=$1
    local timeout=300
    local count=0
    
    log "Waiting for pod with label app=${app_label} to be ready..."
    while [ $count -lt $timeout ]; do
        if $KUBECTL get pods -l app=${app_label} -o jsonpath='{.items[0].status.phase}' 2>/dev/null | grep -q "Running"; then
            log "Pod ${app_label} is ready"
            return 0
        fi
        sleep 5
        count=$((count + 5))
    done
    log "ERROR: Timeout waiting for pod ${app_label}"
    return 1
}

# Function to start port forward with logging
start_port_forward() {
    local app_label=$1
    local local_port=$2
    local remote_port=$3
    local deployment=$4
    local namespace=${5:-default}
    
    log "Starting port forward for ${app_label}: ${local_port} -> ${remote_port} (namespace: ${namespace})"
    
    # Check if port is already in use
    if netstat -tuln | grep -q ":${local_port} "; then
        log "WARNING: Port ${local_port} is already in use"
        return 1
    fi
    
    # Start port forward with nohup to survive script exit
    nohup $KUBECTL port-forward --address=${BIND_ADDRESS} -n ${namespace} deployment/${deployment} ${local_port}:${remote_port} >> "$LOG_FILE" 2>&1 &
    local pid=$!
    
    # Give it a moment to start
    sleep 2
    
    # Check if the process is still running
    if kill -0 $pid 2>/dev/null; then
        log "Port forward for ${app_label} started successfully (PID: $pid)"
        echo $pid >> /var/run/kubernetes-goat-pids.txt
        return 0
    else
        log "ERROR: Port forward for ${app_label} failed to start"
        return 1
    fi
}

# Clean up any existing PID file
rm -f /var/run/kubernetes-goat-pids.txt

# Start port forwarding for each service
log "Setting up port forwarding..."

# Use the actual deployment names from the upstream script
# Sensitive keys in code bases (build-code deployment)
log "Checking for build-code deployment..."
if $KUBECTL get deployment build-code -n default >/dev/null 2>&1; then
    start_port_forward "build-code" 1230 3000 "build-code"
else
    log "WARNING: build-code deployment not found"
fi

# DIND (docker-in-docker) exploitation scenario (health-check deployment)
log "Checking for health-check deployment..."
if $KUBECTL get deployment health-check -n default >/dev/null 2>&1; then
    start_port_forward "health-check" 1231 1234 "health-check"
else
    log "WARNING: health-check deployment not found"
fi

# SSRF in Kubernetes scenario (internal-proxy deployment)
log "Checking for internal-proxy deployment..."
if $KUBECTL get deployment internal-proxy -n default >/dev/null 2>&1; then
    start_port_forward "internal-proxy" 1232 3000 "internal-proxy"
else
    log "WARNING: internal-proxy deployment not found"
fi

# Container escape scenario (hunger-check deployment in big-monolith namespace)
log "Checking for hunger-check deployment in big-monolith namespace..."
if $KUBECTL get deployment hunger-check -n big-monolith >/dev/null 2>&1; then
    start_port_forward "hunger-check" 1233 1234 "hunger-check" "big-monolith"
else
    log "WARNING: hunger-check deployment not found in big-monolith namespace"
fi

# Kubernetes Goat home page
log "Checking for kubernetes-goat-home deployment..."
if $KUBECTL get deployment kubernetes-goat-home -n default >/dev/null 2>&1; then
    start_port_forward "kubernetes-goat-home" 1234 1234 "kubernetes-goat-home"
else
    log "WARNING: kubernetes-goat-home deployment not found"
fi

# Private registry attack scenario
log "Checking for poor-registry deployment..."
if $KUBECTL get deployment poor-registry -n default >/dev/null 2>&1; then
    start_port_forward "poor-registry" 1235 1234 "poor-registry"
else
    log "WARNING: poor-registry deployment not found"
fi

# DoS resources scenario
log "Checking for system-monitor deployment..."
if $KUBECTL get deployment system-monitor -n default >/dev/null 2>&1; then
    start_port_forward "system-monitor" 1236 1234 "system-monitor"
else
    log "WARNING: system-monitor deployment not found"
fi

log "Port forwarding setup complete"
log "Kubernetes Goat is accessible on:"
log "  Main interface: http://$(hostname -I | awk '{print $1}'):1234"
log "  Scenario ports: 1230-1236"

# For systemd forking service, we need to exit after starting the background processes
exit 0